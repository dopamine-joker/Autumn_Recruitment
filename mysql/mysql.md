# 1. MySQL体系构架、存储引擎和索引结构

https://blog.csdn.net/wangfeijiu/article/details/112454405

# 2. 事务四个特性ACID

**事务**具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。

1 、**原子性**

事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做

2 、**一致性**

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

3 、**隔离性**

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

4 、**持续性**

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

# 3. MYSQL锁机制

1. 读锁(共享锁)和写锁(排他锁),表锁，行锁

   https://blog.csdn.net/why15732625998/article/details/80439315#commentBox

   **修正，blog中2.3标题为页锁**

![image-20210403134631266](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210403134631266.png)

![image-20210403134647163](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210403134647163.png)

# 4. [数据库事务隔离级别](https://blog.csdn.net/riemann_/article/details/89901626?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161720291516780357280628%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161720291516780357280628&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-89901626.first_rank_v2_pc_rank_v29&utm_term=%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB&spm=1018.2226.3001.4187)

- **读未提交(Read uncommitted)**

  读未提交，顾名思义，就是**一个事务可以读取另一个未提交事务的数据**。

- **读提交(Read committed)**

  读提交，顾名思义，就是**一个事务要等另一个事务提交后才能读取数据**。

- **重复读(Repeatable read)**

  重复读，就是在**开始读取数据（事务开启）时，不再允许修改操作**。间隙锁是RR隔离级别下防止幻读的主要原因

- **序列化(Serializable)**

  Serializable 是**最高的事务隔离级别**，在该级别下，**事务串行化顺序执行**，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。
  
  <font color=red>大多数数据库默认的事务隔离级别是**Read committed**，比如Sql Server , Oracle。Mysql的默认隔离级别是**Repeatable read**。</font>
  
  ![image-20210403151128946](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210403151128946.png)

# 5. [Mysql的MVCC机制](https://blog.csdn.net/riemann_/article/details/94838870?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161720399616780271574701%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161720399616780271574701&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-94838870.first_rank_v2_pc_rank_v29&utm_term=MVCC&spm=1018.2226.3001.4187)

**多版本并发控制**（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

MVCC是通过在**每行记录后面保存两个隐藏的列**来实现的。这两个列，**一个保存了行的创建时间，一个保存行的过期时间（或删除时间）**。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。
下面看一下在**REPEATABLE READ**隔离级别下，MVCC具体是如何操作的。

**SELECT**
InnoDB会根据以下两个条件检查每行记录：
1、InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2、行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
只有符合上述两个条件的记录，才能返回作为查询结果。
**INSERT**
InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
**DELETE**
InnoDB为删除的每一行保存当前系统版本号作为行删除标识。
**UPDATE**
InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作

# 6. Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

**InnoDB有三种行锁的算法：**

1. **Record Locks** : 单个行记录上的锁。

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

2. **Gap Locks** : 间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

3. **Next-Key Locks** : 1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

# 6.存储引擎

两个最常用的是**Innodb**和**MyISAM**

## 1. Innodb引擎

InnoDB 是一个事务安全的存储引擎（**支持事务**），它具备提交、回滚以及崩溃恢复的功能以保护用户数据。InnoDB 的**行级别锁定**保证数据一致性提升了它的多用户并发数以及性能。InnoDB 将用户数据存储在聚集索引中以减少基于主键的普通查询所带来的 I/O 开销。为了保证数据的完整性，InnoDB 还支持外键约束。默认**使用B+TREE数据结构存储索引**。

**特点**

- **支持事务**，支持4个事务隔离（ACID）级别
- **行级锁定**（更新时锁定当前行）
- 读写阻塞与事务隔离级别相关
- 既能缓存索引又能缓存数据
- **支持外键**
- InnoDB更消耗资源，读取速度没有MyISAM快
- 在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；
- 对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。**数据和索引放在一块**，都位于B+数的叶子节点上；

**业务场景**

- 需要**支持事务**的场景（银行转账之类）
- 适合**高并发**，行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成的
- 数据修改较频繁的业务

**InnoDB引擎调优**

- 主键尽可能小，否则会给Secondary index带来负担
- 避免全表扫描，这会造成锁表
- 尽可能缓存所有的索引和数据，减少IO操作
- 避免主键更新，这会造成大量的数据移动

## 2. MyISAM引擎

MyISAM既**不支持事务**、**也不支持外键**、其优势是访问速度快，但是**表级别的锁定**限制了它在读写负载方面的性能，因此它经常应用于只读或者以读为主的数据场景。**默认使用B+TREE数据结构存储索引**。

**特点**

- **不支持事务**
- **表级锁定**（更新时锁定整个表）
- 读写互相阻塞（写入时阻塞读入、读时阻塞写入；但是读不会互相阻塞）
- 只会**缓存索引**（通过key_buffer_size缓存索引，但是不会缓存数据）
- **不支持外键**
- <font color=red>**读取速度快**</font>

**业务场景**

- **不需要支持事务的场景**（像银行转账之类的不可行）
- 一般读数据的较多的业务
- 数据修改相对较少的业务
- 数据一致性要求不是很高的业务

**MyISAM引擎调优**

- 设置合适索引
- 启用延迟写入，尽量一次大批量写入，而非频繁写入
- 尽量顺序insert数据，让数据写入到尾部，减少阻塞
- 降低并发数，高并发使用排队机制
- MyISAM的count只有全表扫描比较高效，带有其它条件都需要进行实际数据访问

# 7. 常见的索引结构

## 7.1 B树

B树是一种多路搜索树，一棵m阶的B树满足下列条件：

- 树中每个结点至多有m个孩子

- 根结点的儿子数为[2, M]；

- 除根结点以外的非叶子结点的儿子数为[M/2, M]；

- 每个结点存放至少和ceil(m/2)-1至多M-1个关键字；（至少2个关键字）

- 非叶子结点的关键字个数 = 指向子节点的指针个数-1；

- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；

- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

- 所有叶子结点位于同一层；

  ![image-20210405165340547](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405165340547.png)

  ![image-20210405165353358](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405165353358.png)

B树的特征：

- 关键字集合分布在整颗树中；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束；
- 其搜索性能等价于**在关键字全集内做一次二分查找**；
- 自动层次控制；

## 7.2 B+树

B+ Tree
B+树是B-树的变体，也是一种多路搜索树：（❀ 表示两者间的不同点）

- 树中每个结点至多有m个孩子
- 根结点的儿子数为[2, M]；
- 除根结点以外的非叶子结点的儿子数为[M/2, M]；
- 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
- ❀ 非叶子结点的子树指针与关键字个数相同；
- ❀ 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树；（B树是开区间）；
- ❀ 为所有叶子结点增加一个链指针；
- ❀ 所有关键字都在叶子结点出现；

![image-20210405165857000](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405165857000.png)

B+树的特征：

- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 不可能在非叶子结点命中；
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。
- 更适合文件索引系统；

**B+树的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找**；

## 7.3 为什么B+ 树比B 树更适合作为索引？

**性能上**（也即为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？）

- 不同于B树只适合**随机检索**，B+树同时支持**随机检索**和**顺序检索**；
- B+树的磁盘读写代价更低。B+树的**内部结点并没有指向关键字具体信息的指针**，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素。
- B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
- （数据库索引采用B+树的主要原因是，）B-树在提高了磁盘IO性能的同时并没有解决**元素遍历的效率**低下的问题。B+树的叶子节点使用指针顺序连接在一起，**只要遍历叶子节点就可以实现整棵树的遍历**。而且**在数据库中基于范围的查询是非常频繁的**，而B树不支持这样的操作（或者说效率太低）。

## 7.4 HASH索引

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需**一次哈希算法**即可立刻定位到相应的位置，速度非常快。**Memory存储引擎使用Hash**。

![image-20210405194924658](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405194924658.png)

**HASH索引本身是不支持范围查询的，但是如使用Memory存储引擎的表还是可以进行范围查询操作，只是此时的HASH索引会失效**

![image-20210405201413908](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405201413908.png)

# 7. mysql索引

​		索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大查询数据所花费的时间就越多。如果表中查询的列有索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。

　　例如：有一张person表，其中有2W条记录，记录着2W个人的信息。有一个Phone的字段记录每个人的电话号码，现在想要查询出电话号码为xxxx的人的信息。

　　如果没有索引，那么将从表中第一条记录一条条往下遍历，直到找到该条信息为止。

　　如果有了索引，那么会将 Phone 字段，通过一定的方法进行存储，好让查询该字段上的信息时，能够快速找到对应的数据，而不必在遍历2W条数据了。其中MySQL中的索引的存储类型有两种：**BTREE**、**HASH**。 也就是用树或者Hash值来存储该字段。

https://www.cnblogs.com/nananana/p/10387720.html

https://blog.csdn.net/wangfeijiu/article/details/113409719

**索引逻辑分类**:

1. 按功能划分:
   - 主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；
   - 唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；
   - 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；
   - 全文索引：它查找的是文本中的关键词，主要用于全文检索。

2. 按列数划分:
   - 单例索引：一个索引只包含一个列，一个表可以有多个单例索引。
   - 组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效。

**索引物理分类**:

- **聚簇索引**:聚簇是为了提高某个属性(或属性组)的查询速度，把这个或这些属性(称为聚簇码)上具有相同值的元组集中存放在连续的物理块。
- **非聚簇索引**:数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。

虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是**只有InnoDB的主键索引才是聚簇索引**，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。**每张表最多只能拥有一个聚簇索引**。

**InnoDB**使用B+TREE存储数据，**除了主键索引为聚簇索引，其它索引(辅助索引，二级索引)均为非聚簇索引**。

InnoDB使用**B+Tree**数据结构存储索引，根据索引物理结构可将索引划分为**聚簇索引**和**非聚簇索引**（也可称辅助索引或二级索引）。一个表中只能存在一个**聚簇索引（主键索引）**，但可以**存在多个非聚簇索引**。

InnoDB**辅助索引**的访问需要**两次索引查找**，第一次从辅助索引树**找到主键值**，第二次根据主键值**到主键索引树中找到对应的行数据**。

B+树 叶子节点包含数据表中行记录就是**聚簇索引**（索引和数据是一块的）。

![image-20210405191221735](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405191221735.png)

B+树 叶子节点没包含数据表中行记录就是**非聚簇索引**（索引和数据是分开的）。

![image-20210405191238765](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405191238765.png)

MyISAM也使用B+Tree作为索引结构，但具体实现方式却与InnoDB截然不同。**MyISAM使用的都是非聚簇索引**

![image-20210405191312610](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405191312610.png)

![image-20210403152319881](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210403152319881.png)

 **InnoDB索引**和**MyISAM索引**的区别:

**一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。**

**二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录<font color=red>主键的值</font>而不是地址。而MyISAM的辅助索引和主索引没有多大区别，data域存储相应记录的<font color=red>地址</font>。**

InnoDB在MySQL 5.6和更高版本中提供对**全文索引(FULLTEXT )**的支持。

---

**创建索引**

```mysql
-- 创建普通索引 
CREATE INDEX index_name ON table_name(col_name);
-- 创建唯一索引
CREATE UNIQUE INDEX index_name ON table_name(col_name);
-- 创建普通组合索引
CREATE INDEX index_name ON table_name(col_name_1,col_name_2);
-- 创建唯一组合索引
CREATE UNIQUE INDEX index_name ON table_name(col_name_1,col_name_2);
```

**修改表结构创建索引**

```mysql
ALTER TABLE table_name ADD INDEX index_name(col_name);
```

**创建表时直接指定索引**

```mysql
CREATE TABLE table_name (
    ID INT NOT NULL,
    col_name VARCHAR (16) NOT NULL,
    INDEX index_name (col_name)
);
```

**删除索引**

```mysql
-- 直接删除索引
DROP INDEX index_name ON table_name;
-- 修改表结构删除索引
ALTER TABLE table_name DROP INDEX index_name;
```

**创建全文索引**

```mysql
//建表的时候
FULLTEXT KEY keyname(colume1,colume2)  // 创建联合全文索引列
//在已存在的表上创建
create fulltext index keyname on xxtable(colume1,colume2);
alter table xxtable add fulltext index keyname (colume1,colume2);
```

**使用全文索引**

全文索引有独特的语法格式，需要配合match 和 against 关键字使用

- match()函数中指定的列必须是设置为全文索引的列
- against()函数标识需要模糊查找的关键字

```mysql
 create table fulltext_test(
     id int auto_increment primary key,
     words varchar(2000) not null,a
     artical text not null,
     fulltext index words_artical(words,artical)
)engine=innodb default charset=utf8;

insert into fulltext_test values(null,'a','a');
insert into fulltext_test values(null,'aa','aa');
insert into fulltext_test values(null,'aaa','aaa');
insert into fulltext_test values(null,'aaaa','aaaa');
```

# 8. 问题

[面经链接](https://blog.csdn.net/ligupeng7929/article/details/79421205?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161742394716780357226031%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161742394716780357226031&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79421205.first_rank_v2_pc_rank_v29&utm_term=mysql%E9%9D%A2%E7%BB%8F&spm=1018.2226.3001.4187)

1. **如何设计一个高并发的系统**

   ① 数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引的优化

   ② 使用缓存，尽量减少数据库 IO

   ③ 分布式数据库、分布式缓存

   ④ 服务器的负载均衡

2. **索引的底层实现原理和优化**

   **B+树，经过优化的B+树**

   主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。

3. **什么情况下设置了索引但无法使用** 

   ① 以“%”开头的LIKE语句，模糊匹配

   ② OR语句前后没有同时使用索引

   ③ 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）

4.  **对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题**

   a)、**索引的目的是什么？**

   快速访问数据表中的特定信息，提高检索速度

   创建唯一性索引，保证数据库表中每一行数据的唯一性。

   加速表和表之间的连接

   使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间

   b)、**索引对数据库系统的负面影响是什么？**

   负面影响：
   创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。

   c)、**为数据表建立索引的原则有哪些？**

   在最频繁使用的、用以缩小查询范围的字段上建立索引。

   在频繁使用的、需要排序的字段上建立索引

   d)、 **什么情况下不宜建立索引？**

   对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。

   对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等

5. **SQL注入漏洞产生的原因？如何防止？**

   SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。

   mysql注入的例子:

![image-20210403153023142](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210403153023142.png)

6. **sql注入的主要特点**

   变种极多，攻击简单，危害极大

2. **简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）**

   索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
   普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。
   普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。
   主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。
   索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。
   索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。

3. **数据库中的事务是什么?**

   事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。事务的 **四大特性**(ACID),原子性、隔离性、一致性、持久性。

4. **写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）**

   MyISAM、InnoDB、Memory（Heap）、BDB（BerkeleyDB）、Merge、Example、Federated、
   Archive、CSV、Blackhole、MaxDB 等等十几个引擎

5. **优化数据库的方法**

   [MySQL数据库优化的八大方式（经典必看）](https://www.jianshu.com/p/dac715a88b44)

   · 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如'省份'、'性别'最好适用ENUM

   · 使用连接(JOIN)来代替子查询

   · 适用联合(UNION)来代替手动创建的临时表

   · 事务处理

   · 锁定表、优化事务处理

   · 适用外键，优化锁定表

   · 建立索引

   · 优化查询语句

6. **mysql中char与varchar的区别分析**

   1. 都是用来存储字符串的，只是他们的保存方式不一样。

   2. char有固定的长度，而varchar属于可变长的字符类型。
   3. char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）

7. **什么叫视图？游标是什么？**

   答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

     游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

8. **什么是存储过程？用什么来调用？**

   存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。

9. **什么是基本表？什么是视图？**

   基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。  视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表  

10. **[索引失效的情况](https://www.cnblogs.com/wdss/p/11186411.html)**

    - like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。
    - or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效
    - 组合索引，不是使用第一列索引，索引失效。
    - 数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。
    - (在索引列上使用 IS NULL 或 IS NOT NULL操作，索引不一定失效)[https://mp.weixin.qq.com/s/CEJFsDBizdl0SvugGX7UmQ]！！！
    - 在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key<>0 改为 key>0 or key<0W
    - 对索引字段进行计算操作、字段上使用函数
    - 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效

11. **[mysql一级索引和二级索引](http://www.mybatis.cn/archives/941.html)**

    (1) **一级索引**

    索引和数据存储在一起，都存储在同一个B+tree中的叶子节点。一般主键索引都是一级索引。

    (2) **二级索引**

    二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。

     一级索引和二级索引的关系：**回表**
    一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。

12. **使用Memory引擎的表可以进行范围查询吗**

    Hash索引本身确实不支持范围查询，因为它是通过Hash算法来存储的。Memory引擎中使用Hash索引，但是使用Memory引擎的表是可以进行范围查询的，只是它在范围查询时Hash索引会失效。

![image-20210405201703590](C:\Users\78620\AppData\Roaming\Typora\typora-user-images\image-20210405201703590.png)

13. **分析SQL的执行**

    使用**EXPLAIN**关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句。
    
14. **[INNER JOIN，LEFT JOIN，RIGHT JOIN](https://www.cnblogs.com/94cool/p/13985665.html)**

15. **utf8和utf8mb4的区别**

    utf8最多只支持三个字节的UTF-8字符，如chat(100) mysql会为这个字段保留300字节长度（因为一个UTF-8最多三字节）。但保存emoji字符和一些不常用汉字需要4个字节，这时候就需要使用utf8mb4了。











