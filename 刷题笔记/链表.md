## 1. 反转链表

首先创建一个head节点，指向链表第一个节点。

之后依次遍历，依次将节点加到head后面。

eg: 1->2->3->4->5

1. head->1->2->3->4->5
2. head->2->1->3->4->5
3. head->3->2->1->4->5
4. head->4->3->2->1->5
5. head->5->4->3->2->1

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode* cur = pHead;
        ListNode* head = new ListNode(-1);
        head->next = pHead;
        if(cur == nullptr) {
            return nullptr;
        }
        while(cur->next != nullptr) {
            ListNode* next_node = cur->next;
            cur->next = next_node->next;
            next_node->next = head->next;
            head->next = next_node;
        }
        return head->next;
    }
};
```

## 2. 链表是否有环

快慢指针

这里注意判空条件，快指针不为空，且快指针的next指针不为空才能操作

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == nullptr) {
            return false;
        }
        ListNode *p1 = head, *p2 = head;
        while(p2 != nullptr && p2->next != nullptr) {
            p1 = p1->next;
            p2 = p2->next->next;
            if(p1 == p2) {
                return true;
            }
        }
        return false;
    }
};
```

## 3. 链表相加

eg:

input:

list1: 9->3->7 list2: 6->3

output: 

1->0->0->0

模拟加法

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    int carry = 0;
    
    void add(int num, ListNode* head) {
        carry = num/10;
        num %= 10;
        ListNode* tmp = new ListNode(num);
        tmp->next = head->next;
        head->next = tmp;
    }
    
    ListNode* addInList(ListNode* head1, ListNode* head2) {
        // write code here
        ListNode* head = new ListNode(-1);
        stack<ListNode*> stk1;
        stack<ListNode*> stk2;
        ListNode* cur = head1;
        while(cur != nullptr) {
            stk1.push(cur);
            cur = cur->next;
        }
        cur = head2;
        while(cur != nullptr) {
            stk2.push(cur);
            cur = cur->next;
        }
        while(!stk1.empty() && !stk2.empty()) {
            int num = stk1.top()->val + stk2.top()->val + carry;
            add(num, head);
            stk1.pop();
            stk2.pop();
        }
        while(!stk1.empty()) {
            int num = stk1.top()->val + carry;
            add(num, head);
            stk1.pop();
        }
        while(!stk2.empty()) {
            int num = stk2.top()->val + carry;
            add(num, head);
            stk2.pop();
        }
        if(carry) {
            add(1, head);
        }
        return head->next;
    }
};
```

