#  Golang [垃圾回收(gc)](https://zhuanlan.zhihu.com/p/297177002)

下文内容均参考或在以下文章中整理

[图示Golang垃圾回收机制](https://zhuanlan.zhihu.com/p/297177002)

[golang垃圾收集器](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)

## (1) **垃圾回收过程**

**用户程序**`Mutator`通过**内存分配器**`Allocator`在**堆**`Heap`上申请内存，垃圾回收器`Collector`会定时清理**堆**上的内存。内存分配器和垃圾收集器共同管理着程序中的堆内存空间。  

![image-20210908154309631](https://gitee.com/dopamine-joker/image-host/raw/master/image/image-20210908154309631.png)

## (2) **垃圾回收常见算法**

- **<font size=6>引用计数</font>**

    如c++的std::shared_ptr

    **优点**:

    1. 原理和实现都比较简单
    2. 回收的即时性：当对象的引用计数为`0`时立即回收，不像其他`GC`机制需要等待特定时机再回收，提高了内存的利用率
    3. 不需要暂停应用即可完成回收

    **缺点**:

    1. 无法解决循环引用问题
    2. 时间空间成本较大（每个对象要增加计数器，并且要一直修改它）
    3. 会将内存回收分摊到程序运行过程，降低运行效率

- **追踪基础:可达性分析算法**

    判断标记`Mark`对象是否“可达”。“可达”的对象主要包括如下两类:

    - <a id="GCRoot">`GC Root`</a>对象: 包括**全局对象**，**栈上的对象(函数参数与内部变量)**
    - 与`GC Root`对象通过引用链`Reference Chain`相连的对象

    对于不可达的对象，就认为该对象为垃圾对象并回收。

    ![img](https://pic1.zhimg.com/80/v2-55bd8e067a1fb23855320c7422357ffc_720w.jpg)

    **优点**:

    1. 解决循环引用问题
    2. 占用空间更少

    **缺点**:

    1. 比引用计数相比无法立刻识别垃圾对象，需要依赖`GC`线程
    2. 算法在标记时必须**暂停整个程序**，即`Stop The World, SWT`，否则会因其他线程代码修改对象的是否可达状态而造成错误回收

- **<font size=6>标记-清除算法</font>**

    标记-清除`Mark-Sweep`是最基础的追踪是算法。分为`标记`和`清除`两个步骤:

    - 标记:记录需要回收的垃圾对象
    - 清除:标记完成后回收垃圾对象的内存空间

    ![img](https://pic2.zhimg.com/80/v2-cd90a17a0bb9d2f5bdf2bf9e6cda5be1_720w.jpg)

    **优点**:

    1. 算法吞吐量高
    2. 空间利用率高，不需要额外空间

    **缺点**:

    1. 清除后会有大量内存碎片，不利于大对象内存分配，从而导致下一次GC提前

- **<font size=6>标记-复制算法</font>**

    标记-复制`Mark-Copy`将内存分为**大小相同**两块，其中一块用完就将使用中的对象复制到另一块内存中，最后将当前内存回复未使用状态。 

    ![img](https://pic4.zhimg.com/80/v2-bf77fbfcc67e6b890fa1e1c03fed6d93_720w.jpg)

    **优点**:

    - 标记-清除需要大量扫描垃圾对象，标记-复制只需要从`GC Root`出发然后将“可达”对象复制到另外一块即可
    - 解决内存碎片问题

    **缺点**:

    - 对象复制开销大
    - 内存利用率低，相当于可利用内存只有一半

- **<font size=6>标记-整理</font>**

    标记-整理**Mark-Compact**综合了标记-清除和标记-复制。该方法标记所有“可达”对象，然后将存活对象移到内存空间的一段，最后清理端边界外的内存。

    ![img](https://pic3.zhimg.com/80/v2-1a5b782532ef9a0e016ac6b5d7d511f2_720w.jpg)

    **优点**:

    - 解决内存碎片
    - 不需要复制对象

    **缺点**:

    - 整理过程复杂，需多次遍历内存导致`STW`时间比标记-清除更长

## (3) **三色标记法**

上述标记算法都需要`STW`，暂停整个程序。而三色标记可以不暂停程序的情况下完成`可达性分析`。

`GC`线程将所有对象分为三类（三种颜色）

> **白色**: 未搜索的对象，回收周期开始前所有对象为白色，回收周期结束后所有白色的对象为垃圾对象，需要回收。
>
> **灰色**: 正在搜索的对象，但是对象身上还有一个或多个对其他对象的引用没有扫描（即存在指向白色对象的外部指针）
>
> **黑色**: 已完成搜索的对象，黑色对象包括不存在任何引用外部指针的对象和根对象可达的对象。

![tri-color-objects](https://img.draveness.me/2020-03-16-15843705141808-tri-color-objects.png)

**工作流程**

> 1. 初始时所有对象都是白色对象
> 2. 从`GC Root`对象出发，扫描所有可达对象并标记为灰色，放入待处理队列
> 3. 从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列
> 4. 重复上一步骤，直到灰色对象队列为空
> 5. 此时所有剩下的白色对象就是垃圾对象

![img](https://pic4.zhimg.com/80/v2-3ff453ff07291ac6578348c5b4a063cb_720w.jpg)

上述流程中经过三色标记后最后只剩下黑色和白色对象，其中所有白色对象(这里是D)会被回收。

**优点**:

1. 不需要`STW`

**缺点**:

1. 如果垃圾对象产生速度大于回收速度，则垃圾对象会越来越多
2. 线程和上下文的切换会提升回收成本
3. 由于是和用户程序并发执行的，会有并发问题，见下

## (4) **三色标记的并发问题**

上述例子中，在标记过程若用户建立从A对象到D对象的引用，则D由于为白色对象会被回收而造成A野指针错误。

![img](https://pic2.zhimg.com/80/v2-556a9afa216dbf30981f2cfe3ba29999_720w.jpg)

## (5) **三色标记并发问题原因及解决思路**

**原因**:

存在某一黑色对象引用白色对象，并且没有存在任何灰色对象可达到这个白色对象。

**解决思路**:

- 使用`STW`保证标记过程不受干扰
- 使用赋值器屏障技术使得赋值器在进行指针写操作时同步垃圾回收器，保证不破坏三色不变性(下述)

## (6) **三色不变性解决并发问题**

**读写屏障技术**

因此为了在并发或增量的标记算法中保证正确性，就需要达成以下两种**三色不变性(Tri-color invariant)**

- **强三色不变性**: 黑色对象不会指向白色对象，只会指向灰色对象或黑色对象
- **弱三色不变性**: 黑色对象指向的白色对象必须包含一条从灰色对象经过多个白色对象的可达路径

垃圾收集中的屏障技术更像是一个**钩子(Hook)方法**，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和**写屏障**（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会**采用写屏障**保证三色不变性。

## (7) **Dijkstra插入写屏障**

Dijkstra插入写屏障**保持强三色不变性**

```go
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    // 1) 将新下游对象标记为灰色
    shade(ptr)
    // 2) 当前下游对象slot = 新下游对象ptr
    *slot = ptr
}

// 场景一：A之前没有下游, 新添加一个下游对象B, B被标记为灰色
A.DijkstraWritePointer(nil, B)
// 场景二：A将下游对象C更换为B, B被标记为灰色
A.DijkstraWritePointer(C, B)
```

理解起来就是每当执行类似`*slot = ptr`的操作时，就执行上述写屏障，通过shade改变ptr的颜色。若ptr是白色的则会被设置为灰色。

一个对象可以存储在内存中的“栈”或者“堆”，由于“栈”空间容量小且要求相应速度较高，因此“插入写屏障”不适合用于“栈”空间。

![dijkstra-insert-write-barrier](https://img.draveness.me/2020-03-16-15843705141840-dijkstra-insert-write-barrier.png)

步骤:

1. 垃圾收集器将根对象指向的A对象标记成黑色，并将A对象指向的B对象标记成灰色
2. 用户程序修改A对象的指针，将原本指向B改为指向C，这时候**触发写屏障**将C对象标记为灰色
3. 垃圾收集器遍历其他灰色对象，并将它们标记为黑色。

Dijkstra 的插入写屏障在收集过程也有缺点，如在上述过程中不存货的对象B本来应该被回收的，但实际上并没有。而若在第二步和第三步之间再将对象A的指针从指向C改回指向B，那么垃圾收集器仍然认为对象C存活从而不回收。

另外一个缺点是栈上的对象也被垃圾收集器认为是[根对象(GC Root)](#GCRoot)，所以在Dijkstra 插入写屏障中按流程会为栈上的对象加入写屏障，或者在一轮三色标记完成后使用`STW`重新堆栈上的对象重新扫描。前者方法会极大降低栈空间对象的处理速度，而后者方法则会直接暂停用户程序。

## (8) **Yuasa删除写屏障**

Yuasa删除写屏障**保持弱三色不变性**

```go
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    // 1) 将当前下游对象标记为灰色
    shade(*slot)
    // 2) 当前下游对象slot = 新下游对象ptr
    *slot = ptr
}

// 场景一：B被A删除, 将B标记为灰色
A.添加下游对象(B, nil)
// 场景二：B被A删除, 将B标记为灰色
A.添加下游对象(B, C)
```

理解起来就是每当执行类似`*slot = ptr`的操作时，就执行上述写屏障，要注意的是与Dijkstra插入写屏障不同，这里是通过shade改变slot的颜色。若slot是白色的则会被设置为灰色，而新的下游ptr不变。

![yuasa-delete-write-barrier](https://img.draveness.me/2021-01-02-16095599123266-yuasa-delete-write-barrier.png)

步骤:

1. 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；
2. 用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；
3. **用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色**；
4. 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；

Yuasa 删除写屏障通过对 C 对象的着色，保证了 C 对象和下游的 D 对象能够在这一次垃圾收集的循环中存活，避免发生悬挂指针以保证用户程序的正确性。

## (9) **混合写屏障**

go v1.8引入了**混合写屏障**，在v1.7版本之前，运行会使用**dijkstra插入写屏障**保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时**暂停程序、将所有栈对象标记为灰色并重新扫描**，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。

Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了的混合写屏障，该写屏障会**将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色**：

```go
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func HybridWritePointerSimple(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    // 1) 将被删除的下游对象标记为灰色
    shade(*slot)
    // 2) 将新下游对象标记为灰色
    shade(ptr)
    // 3) 当前下游对象slot = 新下游对象ptr
    *slot = ptr
}
```

混合写凭证的步骤:

1. `GC`开始时候将栈上所有的对象标记为黑色，无需`STW`
2. `GC`期间在栈上创建的所有新对象均标记为黑色
3. 将被删除的下游对象标记为灰色
4. 将被增加的下游对象标记为灰色

## (10) **混合写屏障应用场景**

`GC`开始阶段会**将所有栈空间可达对象都标记为黑色**：

![img](https://pic1.zhimg.com/80/v2-35789021d1eb8572ddf8ebf8d35875f0_720w.jpg)

场景一：某个对象从堆对象的下游变成栈对象的下游，这种情况下标记该对象为灰色，该对象就不会被错误地回收

![img](https://pic2.zhimg.com/80/v2-bf66067eb24bdd1306267194a6d14395_720w.jpg)

场景二：某个对象从一个栈对象的下游变成另一个对象的下游，由于对象全都在栈空间对象的可达对象中，因此**混合写屏障不会对这些对象着色**。

![img](https://pic4.zhimg.com/80/v2-85835762eacfb2267ca4eab132061b7f_720w.jpg)

场景三：某个对象从一个堆对象的下游变成另一个堆对象的下游，比如下图中对象G从F的下游移动到Y的下游，为了避免对象`G`被错误回收，我们需要将其标记为灰色

![img](https://pic2.zhimg.com/80/v2-33d5d4e718f09bae4889109f8d815115_720w.jpg)

场景四：某个对象从栈对象的下游变成堆对象的下游，对于栈空间对象不触发写屏障，但是对于被删除的堆空间对象`G`需要标记成灰色以保护它和它的下游对象不被错误删除

![img](https://gitee.com/dopamine-joker/image-host/raw/master/image/v2-a87f234312af61ccb642170745b06493_720w.jpg)
