# 1. extern C 的作用？

C++ 和 C语言编译函数签名方式不一样， extern关键字可以让两者保持统一，这样才能找到对应的函数

# 2. sizeof(1==1) 在 C 和 C++ 中分别是什么结果？

```c
#include<stdio.h>

void main(){
    printf("%d\n", sizeof(1==1));
}
// 4
```

```c++
#include <iostream>
using namespace std;

int main() {
    cout << sizeof(1==1) << endl;
    return 0;
}
// 1
```

C语言
sizeof（1 == 1） === sizeof（1）按照整数处理，所以是4字节，这里也有可能是8字节（看操作系统）
C++
因为有bool 类型
sizeof（1 == 1） == sizeof（true） 按照bool类型处理，所以是1个字节

# 3. 重写，重载，覆盖(override)

(1) **重载：**重载从overload翻译过来，是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

(2) **隐藏：**隐藏是指派生类的函数屏蔽了与其同名的基类函数。注意**只要同名函数**，不管参数列表是否相同，基类函数都会被隐藏。

(3) **重写：**重写翻译自override，也翻译成覆盖（更好一点），是指派生类中存在重新定义的函数。其**函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

# 4. 构造函数、析构函数、虚函数可否声明为内联函数

**构造函数和析构函数声明为内联函数是没有意义的**

《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。其次，**class中的函数默认是inline型**的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。

**是否使用Inline,分情况讨论**

综上，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

# 5. [malloc原理](https://www.cnblogs.com/savionyin/p/12883127.html)

从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：**brk**和**mmap**（不考虑共享内存）。

1. brk是将数据段(.data)的最高地址指针_edata往高地址推；
2. mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。

这两种方式**分配的都是虚拟内存**，**没有分配物理内存**。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。
在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。

**情况一：malloc小于128k的内存**

​	使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：


　　　　![img](https://img2020.cnblogs.com/blog/1260364/202005/1260364-20200513163656747-1550753990.jpg)

1. 进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。
    其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。_edata指针（glibc里面定义）指向数据段的最高地址。

2. 进程调用A=malloc(30K)以后，内存空间如图2：
     malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。_

    你可能会问：只要把_edata+30K就完成内存分配了？_

    事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。

    **也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。**

3. 进程调用B=malloc(40K)以后，内存空间如图3。

**情况二：malloc大于128k的内存**

使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：
　　　　![img](https://img2020.cnblogs.com/blog/1260364/202005/1260364-20200513163756205-575540847.jpg)

4. 进程调用C=malloc(200K)以后，内存空间如图4：
    	默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是**利用mmap系统调用，从堆和栈的中间分配一块虚拟内存**。
    	这样子做主要是因为:
    brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候 **紧缩** 看下面），而mmap分配的内存可以单独释放。
    	当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。
5. 进程调用D=malloc(100K)以后，内存空间如图5；
6. 进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放。


　　　　![img](https://img2020.cnblogs.com/blog/1260364/202005/1260364-20200513163853038-1939891227.jpg)



7. 进程调用free(B)以后，如图7所示：
    	B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？
    	当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。
8. 进程调用free(D)以后，如图8所示：
        B和D连接起来，变成一块140K的空闲内存。
9. 默认情况下：
        当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存**紧缩操作（trim）**。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存**紧缩**，变成图9所示。

# 6. static的作用

1. 隐藏当前文件的全局变量
2. 在函数内定义的，始终存在，且只能初始化一次。
3. static成员变量，不与类对象关联，不能在类声明中初始化，必须**在类定义体外部初始化**。
4. static成员函数，不具有this指针，无法访问类对象的非static成员变量和非static成员函数。

# 7. 静态变量初始化的时间

在C中，静态变量和全局变量一样都在代码执行前初始化，但在C++中标准定义为全局或静态变量在首次用到时才会进行构造。

# 8. `next_permutation`排列函数

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    vector<int> vc{1,2,3};
    do {
        cout << vc[0] << vc[1] << vc[2] << endl;
    } while (next_permutation(vc.begin(), vc.end()));
    return 0;
}
// 输出
/*
123
132
213
231
312
321
*/
```

# 9. const的作用

1. const变量定义必须初始化，之后无法修改

2. const形参可以接收const和非const类型

3. const成员变量只能通过**初始化列表**初始化

    ```c++
    class node {
    public:
        const int num;
        node(int _num):num(_num) {
            cout << "construct" << endl;
        }
    };
    
    int main() {
        node n(100);
        cout << n.num << endl;
    }
    ```

4. const成员函数

    const对象不可以调用非const成员函数，非const对象的话都可以调用；

# 10. mutalbe

在C++中，**mutable**也是为了突破const的限制而设置的。被**mutable**修饰的变量，将永远处于可变的状态，即使在一个const函数中。

# 11. 符号表

编译器会生成一个叫做“符号表”的数据结构来维护变量名和内存地址直接的对应关系。它会搜集变量名，比如我们定义了一个全局的 int a; 那么编译器会为程序预留4个字节（32位平台）的空间，比如起始地址23456788（长度为4），并把变量名“a”和地址23456788保存进符号表，这样程序中对a进行相关操作时，它就会根据符号表找到变量的真正的物理位置（23456788），进行相关操作。 在机器执行程序的时候，会把变量名替换为内存地址（和长度），而不存在任何名称。

# 12. 三大特性

继承，封装，多态

# 13. 为什么构造函数不能是虚函数

1. 从存储空间，虚函数是由对象的虚函数指针指向，此时若对象还没构造，就没有虚函数指针来指向构造函数，互相矛盾。
2. 使用角度，虚函数用来动态绑定，但此时构造函数就是要确切的初始化对象。

因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。

# 14. 为什么析构函数要虚函数

防止内存泄漏

如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当**删除基类指针指向的派生类对象**时就不会触发动态绑定，因而**只会调用基类的析构函数**，而**不会调用派生类的析构函数**。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。

# 15. 可以在构造析构函数调用虚函数吗

可以，虚函数底层实现原理(但是**最好不要在构造和析构函数中调用**) 可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。 effictive c++第九条，绝不在构造和析构过程中调用virtual,因为构造函数中的base的虚函数不会下降到derived上。而是直接调用base类的虚函数。绝不在构造和析构函数中调用virtual函数：

- a) 如果有继承，构造函数会先调用父类构造函数，而如果构造函数中有虚函数，此时子类还没有构造，所以此时的对象还是父类的，不会触发多态。更容易记的是基类构造期间，virtual函数不是virtual函数。
- b) 析构函数也是一样，子类先进行析构，这时，如果有virtual函数的话，子类的内容已经被析构了，C++会视其父类，执行父类的virtual函数。
- c) 总之，在构造和析构函数中，不要用虚函数。如果必须用，那么分离出一个Init函数和一个close函数，实现相关功能即可。

> 《Effective C++》的解释是：
> 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。

# 16. 构造析构函数初始化顺序

1. 构造函数
    - 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
    - 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
    - 派生类构造函数。
2. 析构函数
    - 派生类
    - 成员类
    - 基类

# 17. [智能指针](https://www.cnblogs.com/WindSun/p/11444429.html)

[原理](https://www.cnblogs.com/wxquare/p/4759020.html)

1. unique_ptr

    unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

2. shared_ptr

    shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

3. weak_ptr

    share_ptr虽然已经很好用了，但是有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

    weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr， weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

4. auto_ptr

    （C++98的方案，C++11已经抛弃）采用所有权模式。

# 18. 四种强制转换

1. reinterpret_cast

    reinterpret_cast(expression)

    type-id 必须是一个**指针**、**引用**、**算术类型**、**函数指针**或者**成员指针**。它可以用于类型之间进行强制转换。

    ```c++
    int n = 97;
    //reinterpret_cast
    int *p = &n;
    //以下两者效果相同
    char *c = reinterpret_cast<char*> (p); 
    char *c2 =  (char*)(p);
    ```

2. const_cast

    const_cast(expression)

    该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：

    - 常量指针被转化成非常量的指针，并且仍然指向原来的对象
    - 常量引用被转换成非常量的引用，并且仍然指向原来的对象
    - const_cast一般用于修改底指针。如const char *p形式

    ```c++
     //const_cast
    const int *p2 = &n;
    int *p3 = const_cast<int*>(p2);
    *p3 = 100;
    ```

3. static_cast

    static_cast < type-id > (expression)

    **该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性**。它主要有如下几种用法：

    - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
    - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
    - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
    - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
    - 把空指针转换成目标类型的空指针
    - 把任何类型的表达式转换成void类型

    注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

    ```c++
    //static_cast
    Son* s1 = static_cast<Son*>(b1); //同类型转换
    Son* s2 = static_cast<Son*>(b2); //下行转换，不安全
    cout << "static_cast输出："<< endl;
    cout << s1->d << endl;
    cout << s2->d << endl; //下行转换，原先父对象没有d成员，输出垃圾值
    
    float f1 = 3.14;
    int p = static_cast<int>(f1);
    cout << p << endl;	// 3
    ```

4. dynamic_cast

    有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全

    dynamic_cast(expression)

    该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*

    如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

    dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）

    **dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换**

    在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的

    在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

    ```c++
    //dynamic_cast
    Son* s3 = dynamic_cast<Son*>(b1); //同类型转换
    Son* s4 = dynamic_cast<Son*>(b2); //下行转换，安全
    cout << "dynamic_cast输出：" << endl;
    cout << s3->d << endl;
    if(s4 == nullptr)
        cout << "s4指针为nullptr" << endl;
    else
        cout << s4->d << endl;
    ```

# 19. 移动构造函数

    1) 我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
    2) 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。


​    

# 20. C++临时变量做返回值

    函数调用结束后，返回值被临时存储到**寄存器**中，并**没有放到堆或栈**中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系



# 21. C++ 空指针调用成员函数

c++中本质成员函数就是在参数列表中在增加一个this指针，因此在成员函数中不用到this指针的话还是可以调用的。而虚函数就不行，因此空指针没有虚函数指针指向虚函数表

```c++
#include <iostream>

using namespace std;

class A {
private:
    A() {}
public:
    virtual void show() {
        cout << "show()" << endl;
    }
    void show2() {
        cout << "show2()" << endl;
    }

};

int main() {
    A* a = nullptr;
    a->show();			//出错
    a->show2();			//"show()2"
    return 0;
}
```

# 22. [C++万能引用，引用折叠，完美转发](https://www.cnblogs.com/jmliao/p/14327117.html)

1. **万能引用**

    C++ 11中有万能引用（Universal Reference）的概念：**使用`T&&`类型的形参既能绑定右值，又能绑定左值**。

    但是注意了：**只有发生类型推导(class T)的时候，T&&才表示万能引用**；否则，只能表示右值引用。

    ```c++
    template<typename T>
    void func(T&& param) {
        std::cout << param << std::endl;
    }
    
    void func2(int&& param) {
        std::cout << param << std::endl;
    }
    
    
    int main() {
        int num = 3;
        func2(num);		//报错
        func2(3);		//允许	
        func(num);		////允许
        func(3);		////允许
    }
    ```

2. **引用折叠**

    一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合:

    ```shell
    左值-左值 T& 	& 	# 函数定义的形参类型是左值引用，传入的实参是左值引用
    左值-右值 T& 	&& 	# 函数定义的形参类型是左值引用，传入的实参是右值引用
    右值-左值 T&& 	& 	# 函数定义的形参类型是右值引用，传入的实参是左值引用
    右值-右值 T&& 	&& 	# 函数定义的形参类型是右值引用，传入的实参是右值引用
    ```

    即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。

    就是左值引用会传染，只有纯右值&& && = &&，沾上一个左值引用就变左值引用了

    具体规则是： 
     1.所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&） 
     2.所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）    

    ```c++
    #include <iostream>
    #include <boost/type_index.hpp>
    
    using boost::typeindex::type_id_with_cvr;
    
    template<typename T>
    void PrintTYpe(T &&param) {     //万能引用
        std::cout << "T type:" << type_id_with_cvr<T>().pretty_name() << std::endl;
        std::cout << "param type:" << type_id_with_cvr<decltype(param)>().pretty_name() << std::endl;
    }
    
    int main () {
        int &&rvalue_reference_a = 3;
        PrintTYpe(rvalue_reference_a);		//传入左值
        PrintTYpe(3);						//传入右值
    }
    ```

    ```shell
    T type:int&
    param type:int&
    T type:int
    param type:int&&
    ```

3. **完美转发**

    完美转发 = 引用折叠 + 万能引用 + std::forward

    调用模板函数给另一个函数传值时，为了将参数类型保持原本状态传入函数，需要使用完美转发std:forwrad\<T\>() 

    ```c++
    template<typename T>
    void print(T &t) {
        std::cout << "左值" << std::endl;
    }
    
    template<typename T>
    void print(T &&t) {
        std::cout << "右值" << std::endl;
    }
    
    template<typename T>
    void test_forward(T &&v) {
        print(v);
        print(std::forward<T>(v));
        print(std::move(v));
    }
    
    int main() {
        int num = 3;
        test_forward(num);
        std::cout << "=====" << std::endl;
        test_forward(4);
    }
    ```

    ```shell
    左值
    左值
    右值
    =====
    左值
    右值
    右值
    ```

# 23. 空类的大小

​	1字节

​	如果有子类继承空类后，子类有自己的数据成员，空基类的字节不会加到子类中。

# 24. RAII与RTTI

RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。RTTI并不是什么新的东西，很早就有了这个技术，但是，在实际应用中使用的比较少而已。

# 25. C语言中右移为算数右移(有符号)

# 26. 内存分区

C/C++中内存分5大区：栈，堆，全局/静态存储区，常量存储区，代码区

栈（stack）：指那些由编译器在需要的时候分配，不需要时⾃动清除的变量所在的存储区，效率高，分配的内存空间有限，形参和局部变量分配在栈区，栈是向地地址生长的数据结构，是一块连续的内存

堆（heap）：由程序员控制内存的分配和释放的存储区，是向高地址生长的数据结构，是不连续的存储空间，堆的分配(malloc)和释放(free)有程序员控制，容易造成二次删除和内存泄漏

静态存储区（static）：存放全局变量和静态变量的存储区，初始化的变量放在初始化区，未初始化的变量放在未初始化区。在程序结束后释放这块空间

常量存储区（const）：存放常量字符串的存储区，只能读不能写，const修饰的局部变量存储在常量区（取决于编译器），const修饰的局部变量在栈区

> 这里经验证确实是这样，const局部变量和普通局部变量存储的位置都在栈区，而全局const则存储在常量区。
>
> 字符串存储在常量区，而字符串数组存储在栈区。
>
> eg: char *p="hello", char p[] = "hello"，前者的"hello"存储在常量区，后者的“hello"存储在栈区

程序代码区：存放源程序二进制代码

# 27. 大端小端

大端:高尾端，数字尾端放高地址

小端:低尾端，数字尾端放低地址

![image-20211121164741981](https://cdn.jsdelivr.net/gh/dopamine-joker/image-host/202111211647105.png)

# 28. 双重模板

模板类的成员函数也是个模板，则在外实现时需要两层template

```c++
template<class T>
class AA {
public:
    explicit AA(T _num): num(_num){
        cout << "AA::AA() 常规模板构造" << endl;
    }

    template<class V>
    void func(T val1, V val2);

public:
    T num;
};

template<class T>
template<class V>
void AA<T>::func(T val1, V val2) {
    cout << val1 << "," << val2 << endl;
}
```

# 29. 模板类和其函数的具体实现要放在同一文件

```c++
// person.h
template<class T>
class person {
public:
    explicit person(T num){
        std::cout << "模板构造" << std::endl;
    }

    void func(T num);
};

// 若把下面的实现放在了person.cpp,则编译会报错
template<class T>
void person<T>::func(T num) {
    std::cout << num << std::endl;
}
```

结论: 模板和实现不写在不同文件里面，原因:

因为在**编译时模板并不能生成真正的二进制代码**，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。
