# 1. extern C 的作用？

C++ 和 C语言编译函数签名方式不一样， extern关键字可以让两者保持统一，这样才能找到对应的函数

# 2. sizeof(1==1) 在 C 和 C++ 中分别是什么结果？

```c
#include<stdio.h>

void main(){
    printf("%d\n", sizeof(1==1));
}
// 4
```

```c++
#include <iostream>
using namespace std;

int main() {
    cout << sizeof(1==1) << endl;
    return 0;
}
// 1
```

C语言
sizeof（1 == 1） === sizeof（1）按照整数处理，所以是4字节，这里也有可能是8字节（看操作系统）
C++
因为有bool 类型
sizeof（1 == 1） == sizeof（true） 按照bool类型处理，所以是1个字节

# 3. 重写，重载，覆盖(override)

(1) **重载：**重载从overload翻译过来，是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

(2) **隐藏：**隐藏是指派生类的函数屏蔽了与其同名的基类函数。注意**只要同名函数**，不管参数列表是否相同，基类函数都会被隐藏。

(3) **重写：**重写翻译自override，也翻译成覆盖（更好一点），是指派生类中存在重新定义的函数。其**函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

# 4. 构造函数、析构函数、虚函数可否声明为内联函数

**构造函数和析构函数声明为内联函数是没有意义的**

《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。其次，**class中的函数默认是inline型**的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。

**是否使用Inline,分情况讨论**

综上，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

# 5. [malloc原理](https://www.cnblogs.com/savionyin/p/12883127.html)

从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：**brk**和**mmap**（不考虑共享内存）。

1. brk是将数据段(.data)的最高地址指针_edata往高地址推；
2. mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。

这两种方式**分配的都是虚拟内存**，**没有分配物理内存**。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。
在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。

**情况一：malloc小于128k的内存**

​	使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：


　　　　![img](https://img2020.cnblogs.com/blog/1260364/202005/1260364-20200513163656747-1550753990.jpg)

1. 进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。
    其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。_edata指针（glibc里面定义）指向数据段的最高地址。

2. 进程调用A=malloc(30K)以后，内存空间如图2：
     malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。_

    你可能会问：只要把_edata+30K就完成内存分配了？_

    事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。

    **也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。**

3. 进程调用B=malloc(40K)以后，内存空间如图3。

**情况二：malloc大于128k的内存**

使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：
　　　　![img](https://img2020.cnblogs.com/blog/1260364/202005/1260364-20200513163756205-575540847.jpg)

4. 进程调用C=malloc(200K)以后，内存空间如图4：
    	默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是**利用mmap系统调用，从堆和栈的中间分配一块虚拟内存**。
    	这样子做主要是因为:
    brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候 **紧缩** 看下面），而mmap分配的内存可以单独释放。
    	当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。
5. 进程调用D=malloc(100K)以后，内存空间如图5；
6. 进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放。


　　　　![img](https://img2020.cnblogs.com/blog/1260364/202005/1260364-20200513163853038-1939891227.jpg)



7. 进程调用free(B)以后，如图7所示：
    	B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？
    	当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。
8. 进程调用free(D)以后，如图8所示：
        B和D连接起来，变成一块140K的空闲内存。
9. 默认情况下：
        当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存**紧缩操作（trim）**。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存**紧缩**，变成图9所示。
