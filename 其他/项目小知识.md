# 1. go_chat

## 1. RPC原理

原文链接: https://www.cnblogs.com/LBSer/p/4853234.html

1. **如何调用远程服务**

    　由于各服务部署在不同机器，服务间的调用免不了网络通信过程，服务消费方每调用一个服务都要写一坨网络通信相关的代码，不仅复杂而且极易出错。

        　　如果有一种方式能让我们像调用本地服务一样调用远程服务，而让调用者对网络通信这些细节透明，那么将大大提高生产力。
     
        　　要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：

    ![img](https://images2015.cnblogs.com/blog/522490/201510/522490-20151003120412386-363334260.png)

    > 一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。
    >
    > - 客户端(Client)，服务的调用方。
    > - 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
    > - 服务端(Server)，真正的服务提供者。
    > - 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

    1）服务消费方（client）调用以本地调用方式调用服务；

    2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；

    3）client stub找到服务地址，并将消息发送到服务端；

    4）server stub收到消息后进行解码；

    5）server stub根据解码结果调用本地的服务；

    6）本地服务执行并将结果返回给server stub；

    7）server stub将返回结果打包成消息并发送至消费方；

    8）client stub接收到消息，并进行解码；

    9）服务消费方得到最终结果。

    RPC的目标就是要**2~8**这些步骤都封装起来，让用户对这些细节透明。

2. **如何透明化远程服务调用**

    ​	怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：1） **jdk 动态代理**；2）**字节码生成**。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择**动态代理**方式。

    ​	下面简单介绍下动态代理怎么实现我们的需求。我们需要实现RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello("test")方法时就会调用invoke方法。

    ```java
    public class RPCProxyClient implements java.lang.reflect.InvocationHandler{
        private Object obj;
    
        public RPCProxyClient(Object obj){
            this.obj=obj;
        }
    
        /**
         * 得到被代理对象;
         */
        public static Object getProxy(Object obj){
            return java.lang.reflect.Proxy.newProxyInstance(obj.getClass().getClassLoader(),
                    obj.getClass().getInterfaces(), new RPCProxyClient(obj));
        }
    
        /**
         * 调用此方法执行
         */
        public Object invoke(Object proxy, Method method, Object[] args)
                throws Throwable {
            //结果参数;
            Object result = new Object();
            // ...执行通信相关逻辑
            // ...
            return result;
        }
    }
    ```

    ```java
    public class Test {
        public static void main(String[] args) {
            HelloWorldService helloWorldService = (HelloWorldService)RPCProxyClient.getProxy(HelloWorldService.class);
            helloWorldService.sayHello("test");
        }
    }
    ```

3. **RPC结构拆解**

    ![img](https://images0.cnblogs.com/blog2015/569491/201503/080911415868394.png)

    RPC 服务方通过 `RpcServer` 去导出（export）远程接口方法，而客户方通过 `RpcClient` 去引入（import）远程接口方法。 客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 `RpcProxy` 。 代理封装调用信息并将调用转交给 `RpcInvoker` 去实际执行。 在客户端的 `RpcInvoker` 通过连接器 `RpcConnector` 去维持与服务端的通道 `RpcChannel`， 并使用 `RpcProtocol` 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。

    RPC 服务端接收器 `RpcAcceptor` 接收客户端的调用请求，同样使用 `RpcProtocol` 执行协议解码（decode）。 解码后的调用信息传递给 `RpcProcessor` 去控制处理调用过程，最后再委托调用给 `RpcInvoker` 去实际执行并返回调用结果。

4. **如何对消息进行编码解码**

    上节讲了invoke里需要封装通信细节，而通信的第一步就是要确定客户端和服务端相互通信的消息结构。客户端的请求消息结构一般需要包括以下内容：

    1. 接口名
    2. 方法名
    3. 参数类型，参数值
    4. 超时时间
    5. **requestID**

    返回值

    1. 状态code
    2. **requestID**

    确定这些内容后进行**序列化**和**反序列化**传输

    目前互联网公司广泛使用Protobuf、Thrift、Avro等成熟的序列化解决方案来搭建RPC框架，这些都是久经考验的解决方案。

4. **为什么要有requestID**

    如果使用netty的话，一般会用channel.writeAndFlush()方法来发送消息二进制串，这个方法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的，即对于当前线程来说，将请求发送出来后，线程就可以往后执行了，至于服务端的结果，是服务端处理完成后，再以消息的形式发送给客户端的。于是这里出现以下两个问题：

    1）怎么让当前线程“暂停”，等结果回来后，再向后执行？

    2）如果有多个线程同时进行远程方法调用，这时建立在client server之间的socket连接上会有很多双方发送的消息传递，前后顺序也可能是随机的，server处理完结果后，将结果消息发送给client，client收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？

    　如下图所示，线程A和线程B同时向client socket发送请求requestA和requestB，socket先后将requestB和requestA发送至server，而server可能将responseA先返回，尽管requestA请求到达时间更晚。我们需要一种机制保证responseA丢给ThreadA，responseB丢给ThreadB。

     ![img](https://images2015.cnblogs.com/blog/522490/201510/522490-20151003171953574-1892668698.png)

    　　怎么解决呢？

    1）client线程每次通过socket调用一次远程接口前，生成一个唯一的ID，即requestID（requestID必需保证在一个Socket连接里面是唯一的），一般常常使用AtomicLong从0开始累计数字生成唯一ID；

    2）将处理结果的回调对象callback，存放到全局ConcurrentHashMap里面put(requestID, callback)；

    3）当线程调用channel.writeAndFlush()发送消息后，紧接着执行callback的get()方法试图获取远程返回的结果。在get()内部，则使用**synchronized**获取回调对象callback的锁，再先检测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。

    4）服务端接收到请求并处理后，将response结果（此结果中包含了前面的requestID）发送给客户端，客户端socket连接上专门监听消息的线程收到消息，分析结果，取到requestID，再从前面的ConcurrentHashMap里面get(requestID)，从而找到callback对象，再用synchronized获取callback上的锁，将方法调用结果设置到callback对象里，再调用callback.notifyAll()唤醒前面处于等待状态的线程。

    ```java
    public Object get() {
            synchronized (this) { // 旋锁
                while (!isDone) { // 是否有结果了
                    wait(); //没结果是释放锁，让当前线程处于等待状态
                }
            }
        }
    ```

    ```java
    private void setDone(Response res) {
            this.res = res;
            isDone = true;
            synchronized (this) { //获取锁，因为前面wait()已经释放了callback的锁了
                notifyAll(); // 唤醒处于等待的线程
            }
        }
    ```

5. **如何发布服务**

    为了能实现自动告知，即机器的增添、剔除对调用方透明，调用者不再需要写死服务提供方地址？当然可以，现如今zookeeper被广泛用于实现服务自动注册与发现功能！

    ![img](https://images2015.cnblogs.com/blog/522490/201510/522490-20151003183747543-2138843838.png)

    具体来说，zookeeper就是个分布式文件系统，每当一个服务提供者部署后都要将自己的服务注册到zookeeper的某一路径上: /{service}/{version}/{ip:port}, 比如我们的HelloWorldService部署到两台机器，那么zookeeper上就会创建两条目录：分别为/HelloWorldService/1.0.0/100.19.20.01:16888  /HelloWorldService/1.0.0/100.19.20.02:16888。

    　　zookeeper提供了“心跳检测”功能，它会定时向各个服务提供者发送一个请求（实际上建立的是一个 Socket 长连接），如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除，比如100.19.20.02这台机器如果宕机了，那么zookeeper上的路径就会只剩/HelloWorldService/1.0.0/100.19.20.01:16888。

    　　服务消费者会去监听相应路径（/HelloWorldService/1.0.0），一旦路径上的数据有任务变化（增加或减少），zookeeper都会通知服务消费方服务提供者地址列表已经发生改变，从而进行更新。

    　　更为重要的是zookeeper与生俱来的容错容灾能力（比如leader选举），可以确保服务注册表的高可用性。

## 2. etcd

# 2. web_server

![web_server note](https://gitee.com/dopamine-joker/image-host/raw/master/image/web_server note.png)

